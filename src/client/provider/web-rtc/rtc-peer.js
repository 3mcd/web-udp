// @flow

import type {
  RTCDataChannelEvent,
  RTCIceCandidate,
  RTCPeerConnection,
  RTCPeerConnectionIceEvent,
  RTCSessionDescription
} from "wrtc";

import type { Connection } from "..";

import DataChannel from "./data-channel";

const DATA_CHANNEL_OPTIONS = {
  ordered: true,
  reliable: false
};

export interface PeerInterface {
  channel(string): Promise<Connection>;
  offer(): void;
  answer(RTCSessionDescription): void;
  setRemoteDescription(RTCSessionDescription): void;
  addIceCandidate(RTCIceCandidate): void;
}

export type PeerOptions = {
  onChannel: DataChannel => mixed,
  onICE: RTCIceCandidate => mixed,
  onSDP: RTCSessionDescription => mixed,
  pc: RTCPeerConnection
};

export default class RTCPeer implements PeerInterface {
  _channels: { [string]: DataChannel } = {};

  _initiator: boolean = false;

  _pc: RTCPeerConnection;

  _onChannel: DataChannel => mixed;

  _onICE: RTCIceCandidate => void;

  _onSDP: RTCSessionDescription => void;

  constructor(options: PeerOptions) {
    const { onChannel, onICE, onSDP, pc } = options;

    this._onICE = onICE;
    this._onSDP = onSDP;
    this._onChannel = onChannel;
    this._pc = pc;
    this._pc.addEventListener("datachannel", this._onDataChannel);
    this._pc.addEventListener("icecandidate", this._onIceCandidate);
  }

  channel(id: string): Promise<Connection> {
    // Create a RTCDataChannel with the id as the label.
    const dc = this._pc.createDataChannel(id, DATA_CHANNEL_OPTIONS);

    return new Promise(r => {
      const handle = () => {
        const channel = new DataChannel({ dc });
        this._channels[id] = channel;
        r(channel);
        this._onChannel(channel);
        dc.removeEventListener("open", handle);
      };
      dc.addEventListener("open", handle);
    });
  }

  /**
   * Create an offer session description.
   */
  offer() {
    this._pc.createOffer(this._onLocalSDP, console.error, null);
  }

  /**
   * Create an answer session description.
   */
  answer() {
    this._pc.createAnswer(this._onLocalSDP, console.error, null);
  }

  _onLocalSDP = (sdp: RTCSessionDescription) => {
    this._pc.setLocalDescription(sdp);
    this._onSDP(sdp);
  };

  _onIceCandidate = (e: RTCPeerConnectionIceEvent) => {
    this._onICE(e.candidate);
  };

  _onDataChannel = (e: RTCDataChannelEvent) => {
    const { channel: dc } = e;
    let channel = this._channels[dc.label];

    if (channel) {
      return;
    }

    channel = this._channels[dc.label] = new DataChannel({ dc });

    this._onChannel(channel);
  };

  /**
   * Handle remote session description generated by answer.
   */
  setRemoteDescription(sdp: RTCSessionDescription) {
    this._pc.setRemoteDescription(sdp);
  }

  addIceCandidate(ice: RTCIceCandidate) {
    if (ice === null) {
      return;
    }
    this._pc.addIceCandidate(ice);
  }
}
