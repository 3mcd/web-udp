// @flow

import type {
  RTCDataChannelEvent,
  RTCIceCandidate,
  RTCPeerConnection,
  RTCPeerConnectionIceEvent,
  RTCSessionDescription
} from "wrtc";

import type { Connection } from "..";

import DataChannel from "./data-channel";

// Enforce UDP-like SCTP messaging.
const DATA_CHANNEL_OPTIONS = {
  ordered: false,
  reliable: false
};

export interface PeerInterface {
  channel(string): Promise<Connection>;
  offer(): void;
  answer(RTCSessionDescription): void;
  setRemoteDescription(RTCSessionDescription): void;
  addIceCandidate(RTCIceCandidate): void;
}

export type PeerOptions = {
  onClose: (...mixed[]) => mixed,
  onChannel: DataChannel => mixed,
  onICE: RTCIceCandidate => mixed,
  onSDP: RTCSessionDescription => mixed,
  pc: RTCPeerConnection
};

export default class RTCPeer implements PeerInterface {
  _channels: { [string]: DataChannel } = {};

  _pc: RTCPeerConnection;

  _onClose: (...mixed[]) => mixed;
  _onChannel: DataChannel => mixed;
  _onICE: RTCIceCandidate => mixed;
  _onSDP: RTCSessionDescription => mixed;

  constructor(options: PeerOptions) {
    const { onChannel, onClose, onICE, onSDP, pc } = options;

    this._onICE = onICE;
    this._onSDP = onSDP;
    this._onChannel = onChannel;
    this._onClose = onClose;
    this._pc = pc;
    this._pc.addEventListener("datachannel", this._onDataChannel);
    this._pc.addEventListener("icecandidate", this._onIceCandidate);
    this._pc.addEventListener(
      "signalingstatechange",
      this._onSignalingStateChange
    );
  }

  channel(id: string): Promise<Connection> {
    // Create a RTCDataChannel with the id as the label.
    const dc = this._pc.createDataChannel(id, DATA_CHANNEL_OPTIONS);

    return new Promise(resolve => {
      const handle = () => {
        const channel = (this._channels[dc.label] = new DataChannel({
          dc
        }));
        resolve(channel);
        this._onChannel(channel);
      };
      dc.addEventListener("open", handle);
    });
  }

  /**
   * Create an offer session description.
   */
  offer() {
    this._pc.createOffer(this._onLocalSDP, console.error, null);
  }

  /**
   * Create an answer session description.
   */
  answer() {
    this._pc.createAnswer(this._onLocalSDP, console.error, null);
  }

  _onLocalSDP = (sdp: RTCSessionDescription) => {
    this._pc.setLocalDescription(sdp);
    this._onSDP(sdp);
  };

  _onIceCandidate = (e: RTCPeerConnectionIceEvent) => {
    this._onICE(e.candidate);
  };

  _onDataChannel = (e: RTCDataChannelEvent) => {
    const { channel: dc } = e;

    let channel = this._channels[dc.label];

    if (channel) {
      return;
    }

    channel = this._channels[dc.label] = new DataChannel({ dc });

    this._onChannel(channel);
  };

  _onSignalingStateChange = () => {
    const { connectionState } = this._pc;

    switch (connectionState) {
      case "disconnected":
      case "failed":
      case "closed":
        this._onClose();
        break;
      default:
        break;
    }
  };

  /**
   * Handle remote session description generated by answer.
   */
  setRemoteDescription(sdp: RTCSessionDescription) {
    this._pc.setRemoteDescription(sdp);
  }

  addIceCandidate(ice: RTCIceCandidate) {
    if (ice === null) {
      return;
    }
    this._pc.addIceCandidate(ice);
  }

  close() {
    this._pc.close();
    for (let id in this._channels) {
      this._channels[id].close();
    }
  }
}
